#!./venv/bin/python3

import easyocr
import argparse
import os
import cv2
import pandas
from colorama import Fore, Style
import math
import re
import datetime
import platform
import warnings
import subprocess
import openpyxl
import math

DESCRIPTION = '''\
-----------------------------------------------------------------------------------------------------------
Description:
  A lightweight OCR (Optical Character Recognition) slip processing tool for scanning and extracting data 
  from JPG-format or JPEG-format images located in the provided file(s) or directory path(s).
  The extracted information  will be automatically converted into a DataFrame and exported as a .csv file
  by default. Optionally, it can also be saved as .xlsx.
-----------------------------------------------------------------------------------------------------------'''

EPILOG = '''\
-----------------------------------------------------------------------------------------------------------
• If the --append option is used, the --open and --filename options will be ignored.
• The tool supports only .csv and .xlsx file formats for input and output.
• Directory traversal is limited to the top level (level 0).
• When using --filename, the specified file **must not already exist** — the tool will stop if the file exists.
• If no output file is specified, the default file will be: ./readslip_YYYYMMDD_HHMMSS.csv
-----------------------------------------------------------------------------------------------------------'''

LANGUAGE = 'THA'
MONTHS = ('ม.ค.', 'ก.พ.', 'มี.ค.', 'เม.ย.', 'พ.ค.', 'มิ.ย.', 'ก.ค.', 'ส.ค.', 'ก.ย.', 'ต.ค.', 'พ.ย.', 'ธ.ค.')
REPLACE_MONTHS = {
    '๓.ค.' : 'ต.ค.',
    'w.ย.' : 'พ.ย.',
    'w.ค.' : 'พ.ค.',
    'ก.w.' : 'ก.พ.',
}
IMG_EXTENTIONS = ('.jpg', '.jpeg')
FILE_EXTENTIONS = ('.csv', '.xlsx')
LINE_CLEAN = '\033[2K'
LINE_BACK = f'\033[{1}F' 
LINE = f'{Fore.YELLOW}=========================================================={Style.RESET_ALL}' # 58
LOGO = f'{LINE}\n{Fore.YELLOW}║= {Fore.WHITE}{'READSLIP':^52} {Fore.YELLOW}=║\n{LINE}'
CLEAN = f'{LINE_CLEAN}{LINE_BACK}{LINE_CLEAN}{LINE_BACK}{LINE_CLEAN}'
COMPANYS = ('ATR', 'AI', 'SM', 'NA')
COLUMNS = {'THA':['วัน', 'เวลา', 'จำนวน', 'บริษัท', 'รายการ', 'ชื่อไฟล์', 'sort'],
           'ENG':[ 'date', 'time', 'amount', 'company', 'noted', 'filename', 'sort']}
REPLACE_WORDS = {
    'al ': 'AI ',
    '3ขs477' : '3ขร477',
    '7||5v0' : 'TIISVO',
    'พัสด ' : 'พัสดุ ',
    '3๗ษ9296' : '3ฒษ9296',
    'พัสดฺ' : 'พัสดุ',
    ' /|' : ' IV',
    ' (5' : ' CS',
    ' /n/|' : ' INV',
    ' t01 ' : ' TOT ',
    'เครื่องถื่ม' : 'เครื่องดื่ม',
    'smp|[' : 'SMPIE',
    '3๗ผ6819' : '3ฒผ6819',
    'ประกันรถฺญศ9122' : 'ประกันรถ ญศ9122',
    '$n1|' : 'SN1I',
    'ศุาวุฒิ' : 'ศุภวุฒิ',
    'ทางถ่วน' : 'ทางด่วน',
    ' ฺ' :  ' ',
    'BAP|[' : 'BAPIE',
    'BAP|E' : 'BAPIE',
    'ยีเอสยัวช่า' : 'ยีเอสยัวซ่า',
    'นำมัน' : 'น้ำมัน',
    '๓.ย.' : 'ต.ค.'
}

def main() -> int:
    print(LOGO)
    args = _argument_parsing()
    if not args : return 1
    items, total_files = _list_items(args.paths)
    try:
        system = _system_ignore_wanring()
        data = [] if not args.open and not args.append else _open_file(args.append if args.append else args.open)
        if data == None: return 1
        print(f'{Fore.YELLOW}[PROCESS] LOADING OCR MODELS.{Style.RESET_ALL}')
        reader_tha = easyocr.Reader(['en', 'th'])
        reader_eng = easyocr.Reader(['en'])
        fail = 0
        print(f'{LINE}\n\n')
        for index ,item in enumerate(items):
            print(f'{CLEAN}[WAITING] {item}{Style.RESET_ALL}')
            _update_show_progress(index, total_files, fail)
            _, extention = os.path.splitext(item)
            if extention.lower() in IMG_EXTENTIONS:
                try:
                    image = _get_image(item)
                    contents_tha = reader_tha.readtext(image, detail=0, paragraph=True)
                    contents_eng = reader_eng.readtext(image, detail=0, paragraph=True)
                    amount, date, time, company, noted, sort = _contents_parsing(contents_tha, contents_eng)
                    new_data = [date, time,  amount, company, noted, _hyperlink(item, system), sort]
                    data += [{key: value for key, value in zip(COLUMNS[LANGUAGE], new_data)}]
                    print(f'{Fore.GREEN}{CLEAN}{LINE_BACK}{LINE_CLEAN}[SUCCESS] {item}{Style.RESET_ALL}')
                except FileNotFoundError:
                    print(f'{Fore.RED}{CLEAN}{LINE_BACK}{LINE_CLEAN}[FAILED] {item}{Style.RESET_ALL}')
                    error(f'File not found :: {item}')
                    fail += 1
                except Exception as e:
                    print(f'{Fore.RED}{CLEAN}{LINE_BACK}{LINE_CLEAN}[FAILED] {item}{Style.RESET_ALL}')
                    error(f'{e}')
                    fail += 1
            _update_show_progress(index + 1, total_files, fail, True)
        print(f'\n{LINE}')
    except KeyboardInterrupt: return 1
    return 0 if not len(data) else _export_file(data, args.filename if not args.append else args.append, args.xlsx)

def _update_show_progress(current: int, total: int, fail: int, end=False) -> None:
    percentage = math.ceil((current * 100) / total)
    blocks = '█' * math.ceil(percentage * 0.4)
    print(LINE)
    print(f'{Fore.YELLOW}[PROCESS] [{Style.RESET_ALL}{blocks:<40}{Fore.YELLOW}] {percentage:01}%{Style.RESET_ALL}', flush=True)
    print(f'{Fore.YELLOW}[PROCESS] {Style.RESET_ALL}[CURRENT: {current}/{total}]  {Fore.GREEN}[SUCCESS: {current - fail}]  {Fore.RED}[FAILED: {fail}] {Style.RESET_ALL}', flush=True, end='')
    return None

def _hyperlink(file_path: str, system: str) -> str:
    abs_path = os.path.abspath(file_path)
    if system == "Windows":
        window_path = abs_path.replace("\\", "/")
        path = f'file:///{window_path}'
    elif system in ["Darwin", "Linux"]:
        path = f'file://{abs_path}'
    else:
        path = ''
    return f'=HYPERLINK("{path}", "{os.path.basename(file_path)}")'

def _open_file(filename: str) -> list:
    try:
        _, extention = os.path.splitext(filename)
        with open(filename, 'r') as file:
            if extention in FILE_EXTENTIONS:
                data = pandas.read_csv(file) if extention == '.csv' else pandas.read_excel(file)
            else:
                return error(f'Invalid extention to open :: {filename}', color=True)
    except FileNotFoundError:
        return error(f'File not found :: {filename}', color=True)
    except Exception as e:
        return error(f'{e}', color=True)
    return data.to_dict(orient='records')

def _filename_default(xlsx) -> str:
    now = datetime.datetime.now()
    splited_now = str(now).split(' ')
    date = splited_now[0].replace('-', '')
    time = splited_now[1].split('.')[0].replace(':', '')
    return  f'readslips_{date}_{time}.{"csv" if not xlsx else "xlsx"}'

def _to_excel(filename: str, data: list) -> None:
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = "readslips"
    worksheet.append([item for item in COLUMNS[LANGUAGE]])
    for row in data:
        path = row[COLUMNS[LANGUAGE][5]].split('\"')
        worksheet.append([ row[COLUMNS[LANGUAGE][0]], row[COLUMNS[LANGUAGE][1]],
                           row[COLUMNS[LANGUAGE][2]], row[COLUMNS[LANGUAGE][3]],
                           row[COLUMNS[LANGUAGE][4]], path[3] ])
        cell = worksheet.cell(row=worksheet.max_row, column=6)
        cell.hyperlink = path[1]
        cell.font = openpyxl.styles.Font(color="0000FF", underline="single") 
    workbook.save(filename)
    return None

def _export_file(data: list, filename: str, xlsx: bool) -> None:
    try:
        data_frame = pandas.DataFrame(data)
        sorted_df = data_frame.sort_values(by=COLUMNS[LANGUAGE][6]).drop(columns=COLUMNS[LANGUAGE][6]).reset_index(drop=True)
        if not filename:
            filename = _filename_default(xlsx)
        root, extention = os.path.splitext(filename)
        print(f'{Fore.YELLOW}[PROCESS] EXPORTING FILE.{Style.RESET_ALL}')
        if extention == '.xlsx' or (xlsx and not extention):
            filename = filename if extention else filename + '.xlsx'
            _to_excel(filename, sorted_df.to_dict(orient='records'))
        elif extention == '.csv' or not extention:
            _to_csv(sorted_df, filename, extention)
        print(f'{Fore.YELLOW}[SUCCESS] {Fore.GREEN}COMPLETE {Fore.YELLOW}=SAVED=TO=> {Fore.GREEN}[{Style.RESET_ALL} {filename}{'.csv' if not extention and not xlsx else extention}{Fore.GREEN} ]{Style.RESET_ALL}')
    except Exception as e:
        return error(f'{Fore.RED}readslips: ERROR: Cannot save file.: {filename}{'.csv' if not extention else extention}\n{e}{Style.RESET_ALL}', 1, True)
    return 0

def _to_csv(dataframe, filename, extention) -> None:
    for index, value in enumerate(dataframe['ชื่อไฟล์']):
        dataframe.loc[index, 'ชื่อไฟล์'] = value.split(',')[-1].strip(',") ')
    dataframe.to_csv(filename if extention == '.csv' else filename + '.csv', index=False)
    return None

def _list_items(paths: list) -> list:
    def file_extension_add(file) -> bool:
        _, extention = os.path.splitext(file)
        if extention.lower() in IMG_EXTENTIONS:
            items.append(file)
            return True
        return False
    
    items = []
    for path in paths:
        if os.path.isdir(path):
            for item in os.listdir(path):
                file_extension_add(os.path.join(path, item))
        else:
             if not file_extension_add(path):
                error(f'Invalid extention of file :: {path}', color=True)
    return items, len(items)

def _contents_parsing(contents_tha: list, contents_eng):
    contents_tha[-1] = _word_corrected(contents_tha[-1], REPLACE_WORDS)
    date_regx = r"(\d{2})\s(" + "|".join(MONTHS) + r")\s(\d{4})\s(\d{2}:\d{2})"
    if re.search(date_regx, contents_tha[-1]):
        contents_tha += _split_date_noted(contents_tha.pop())
    for index, value in enumerate(contents_tha):
        value = _word_corrected(value, REPLACE_MONTHS)
        if re.search("จำนวนเงิน", value):
            amount = _amount_parsing(contents_tha[index + 1])
        elif re.search(date_regx, value):
            date, time, sort = _date_parsing(value)
            break
    company, noted = _noted_parsing(' '.join(contents_tha[-2:]) if len(contents_tha[-2]) < 4 else contents_tha[-1], contents_eng[-1])
    return amount, date, time, company, noted, sort

def show_image(image) -> None:
    cv2.imshow('show_images', image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    return None

def _get_image(image_path: str):
    image = cv2.imread(image_path)
    height, width, _ = image.shape
    x_start, y_start, x_end, y_end = 0, math.floor(height * 0.60), width, height - 80
    cropped_img = image[y_start:y_end, x_start:x_end]
    gray_img = cv2.cvtColor(cropped_img, cv2.COLOR_BGR2GRAY)
    return gray_img

def _split_date_noted(content: str) -> list:
    index = content.index(":");
    return [ content[:index + 3], content[index + 4:] ]

def _amount_parsing(amount: str) -> str:
    return amount[:-4].replace('o', '0') if amount.index(' บาท') else amount.replace('o', '0')

def _date_parsing(date: str) -> str:
    splited = date.split()
    date = '/'.join([splited[0], f'{MONTHS.index(splited[1]) + 1:02}', splited[2]])
    time = splited[3]
    sort = splited[2] + f'{MONTHS.index(splited[1]) + 1:02}' + splited[0] + splited[3]
    return date, time, sort

def _noted_parsing(noted_tha, noted_eng) -> str:
    result = ''
    index = 0
    length = len(noted_tha)
    while index < length:
        if 'a' <= noted_tha[index] <= 'z':
            word = ''
            while index < length and 'a' <= noted_tha[index] <= 'z':
                word += noted_tha[index]
                index += 1
            word_length = len(word)
            try:
                start = noted_eng.lower().index(word)
                result += noted_eng[start:start + word_length]
                noted_eng = noted_eng[start + word_length:]
            except:
                pass
        else:
            result += noted_tha[index]
            index +=  1;
    splited_result = result.split()
    if splited_result[0] in COMPANYS:
        return splited_result[0], ' '.join(splited_result[1:])
    return '', result

def _word_corrected(noted, correct_words):
    for key, value in correct_words.items():
        noted = noted.replace(key, value)
    return noted

def _system_ignore_wanring() -> str:
    system = platform.system()
    if system == "Darwin":
        try:
            chip_info = subprocess.check_output(["sysctl", "-n", "machdep.cpu.brand_string"]).decode()
            if "Apple" in chip_info:
                warnings.filterwarnings("ignore", message=".*pin_memory.*")
        except Exception:
            pass
    return system

def _argument_parsing() -> argparse.ArgumentParser | None:
    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter, add_help=False,
                                    prog="readslips", description=DESCRIPTION, epilog=EPILOG,)
    parser.add_argument("paths",
                        type=str,
                        metavar="PATHS",
                        nargs='*',
                        help="One or more file paths or directories containing slip images.")
    parser.add_argument("-h", "--help",
                        action="help",
                        help="Show this help message and exit.")
    parser.add_argument("-v", "--version",
                        action="version",
                        version="%(prog)s 1.0.0 beta",
                        help="Show the current version of the program and exit.\n ")
    parser.add_argument("-x", "--xlsx",
                        action="store_true",
                        default=False,
                        help="Export the result as an .xlsx file. When the --filename option is specified, this option will be ignored.\n ")
    parser.add_argument("-f", "--filename",
                        type=str,
                        metavar="FILE_NAME",
                        help="Specify the name of the output file to export results.\n ")
    parser.add_argument("-o", "--open", 
                        type=str,
                        metavar="FILE_NAME",
                        help="Specify a file to open and load existing data.\n ")
    parser.add_argument("-a", "--append",
                        type=str,
                        metavar="FILE_NAME",
                        help="Append new data to an existing file. When this option is used, both --open and --filename will be ignored.")
    args = parser.parse_args()
    if not args.append and args.filename and os.path.isfile(args.filename):
        return error(f'Duplicate file name to export :: {args.filename}', None, True)
    if args.filename:
        filename = args.filename.split('.')
        if len(filename) > 1 and not args.xlsx and not args.filename.split('.')[-1] in FILE_EXTENTIONS:
            return error(f'Not support save file extenion :: {args.filename}', None, True)
    if not args.paths:
        return error(f'The following arguments are required: PATHS', None, True)
    return args

def error(message: str, code: int=None, color: bool=False) -> int | None:
    print(f"{Fore.RED if color else Style.RESET_ALL}readslip: ERROR: {message}{Style.RESET_ALL}")
    return code

if __name__ == "__main__":
    main()
